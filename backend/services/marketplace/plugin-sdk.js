/**
 * PLUGIN SDK - Backend service for plugin management
 * Provides SDK methods, validation, and lifecycle management
 */

import crypto from 'crypto';

// Plugin manifest schema
const MANIFEST_SCHEMA = {
  required: ['id', 'name', 'version', 'main', 'permissions'],
  optional: ['description', 'author', 'homepage', 'repository', 'hooks', 'config'],
};

// Available permissions
const AVAILABLE_PERMISSIONS = {
  // Data Access
  'data:read': 'Read user data',
  'data:write': 'Write user data',
  'data:delete': 'Delete user data',
  
  // Network Access
  'network:fetch': 'Make HTTP requests',
  'network:websocket': 'Use WebSocket connections',
  
  // AI Features
  'ai:chat': 'Use chat completions',
  'ai:embeddings': 'Generate embeddings',
  'ai:images': 'Generate images',
  
  // Storage
  'storage:local': 'Use local storage',
  'storage:cloud': 'Use cloud storage',
  
  // System
  'system:notifications': 'Send notifications',
  'system:clipboard': 'Access clipboard',
  
  // Tools
  'tools:execute': 'Execute other tools',
  'tools:compose': 'Compose tool chains',
};

// Risk levels for permissions
const PERMISSION_RISK = {
  'data:read': 'low',
  'data:write': 'medium',
  'data:delete': 'high',
  'network:fetch': 'medium',
  'network:websocket': 'medium',
  'ai:chat': 'low',
  'ai:embeddings': 'low',
  'ai:images': 'medium',
  'storage:local': 'low',
  'storage:cloud': 'medium',
  'system:notifications': 'low',
  'system:clipboard': 'medium',
  'tools:execute': 'medium',
  'tools:compose': 'low',
};

class PluginSDK {
  constructor() {
    this.registeredPlugins = new Map();
    this.pluginInstances = new Map();
    this.hookRegistry = new Map();
    this.filterRegistry = new Map();
  }

  /**
   * Generate unique plugin ID
   */
  generatePluginId(name) {
    const slug = name.toLowerCase().replace(/[^a-z0-9]/g, '-');
    const hash = crypto.randomBytes(4).toString('hex');
    return `plugin_${slug}_${hash}`;
  }

  /**
   * Validate plugin manifest
   */
  validateManifest(manifest) {
    const errors = [];
    const warnings = [];

    // Check required fields
    for (const field of MANIFEST_SCHEMA.required) {
      if (!manifest[field]) {
        errors.push(`Missing required field: ${field}`);
      }
    }

    // Validate version format (semver)
    if (manifest.version && !/^\d+\.\d+\.\d+(-[\w.]+)?$/.test(manifest.version)) {
      errors.push('Version must be in semver format (e.g., 1.0.0)');
    }

    // Validate permissions
    if (manifest.permissions) {
      for (const perm of manifest.permissions) {
        if (!AVAILABLE_PERMISSIONS[perm]) {
          errors.push(`Unknown permission: ${perm}`);
        }
      }
    }

    // Validate main file
    if (manifest.main && !manifest.main.endsWith('.js')) {
      warnings.push('Main file should be a JavaScript file (.js)');
    }

    // Check for high-risk permissions
    const highRiskPerms = (manifest.permissions || []).filter(
      p => PERMISSION_RISK[p] === 'high',
    );
    if (highRiskPerms.length > 0) {
      warnings.push(`Plugin requests high-risk permissions: ${highRiskPerms.join(', ')}`);
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings,
      riskLevel: this.calculateRiskLevel(manifest.permissions || []),
    };
  }

  /**
   * Calculate overall risk level
   */
  calculateRiskLevel(permissions) {
    const risks = permissions.map(p => PERMISSION_RISK[p] || 'low');
    if (risks.includes('high')) return 'high';
    if (risks.includes('medium')) return 'medium';
    return 'low';
  }

  /**
   * Create plugin scaffold/template
   */
  createPluginTemplate(name, description, permissions = []) {
    const id = this.generatePluginId(name);
    
    return {
      manifest: {
        id,
        name,
        version: '1.0.0',
        description,
        main: 'index.js',
        permissions,
        hooks: {},
        config: {},
      },
      files: {
        'index.js': this.generateMainTemplate(name),
        'README.md': this.generateReadmeTemplate(name, description),
        'package.json': this.generatePackageJson(name, description),
      },
    };
  }

  generateMainTemplate(name) {
    return `/**
 * ${name} Plugin
 * Auto-generated by Plugin SDK
 */

// Plugin lifecycle hooks
export function onInit(context) {
  console.log('Plugin initialized:', context.pluginId);
}

export function onDestroy(context) {
  console.log('Plugin destroyed:', context.pluginId);
}

// Main execution function
export async function execute(input, context) {
  const { data, config, permissions } = context;
  
  // Your plugin logic here
  const result = {
    processed: true,
    input: input,
    timestamp: new Date().toISOString()
  };
  
  return result;
}

// Optional: Hook handlers
export const hooks = {
  'tool:beforeExecute': async (payload, context) => {
    // Modify data before tool execution
    return payload;
  },
  'tool:afterExecute': async (payload, context) => {
    // Process data after tool execution
    return payload;
  }
};

// Optional: Filter handlers  
export const filters = {
  'output:transform': async (value, context) => {
    // Transform output data
    return value;
  }
};
`;
  }

  generateReadmeTemplate(name, description) {
    return `# ${name}

${description}

## Installation

Install via the marketplace or manually add to your plugins directory.

## Usage

\`\`\`javascript
// The plugin will be automatically loaded
// Configure via the plugin settings panel
\`\`\`

## Configuration

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| enabled | boolean | true | Enable/disable the plugin |

## Hooks

This plugin listens to the following hooks:
- \`tool:beforeExecute\` - Called before tool execution
- \`tool:afterExecute\` - Called after tool execution

## License

MIT
`;
  }

  generatePackageJson(name, description) {
    return JSON.stringify({
      name: name.toLowerCase().replace(/\s+/g, '-'),
      version: '1.0.0',
      description,
      main: 'index.js',
      type: 'module',
      keywords: ['plugin', 'marketplace'],
      license: 'MIT',
    }, null, 2);
  }

  /**
   * Register a plugin
   */
  async registerPlugin(manifest, code) {
    const validation = this.validateManifest(manifest);
    if (!validation.valid) {
      return {
        success: false,
        errors: validation.errors,
      };
    }

    const pluginData = {
      manifest,
      code,
      registeredAt: new Date(),
      enabled: false,
      instances: 0,
    };

    this.registeredPlugins.set(manifest.id, pluginData);

    return {
      success: true,
      pluginId: manifest.id,
      warnings: validation.warnings,
      riskLevel: validation.riskLevel,
    };
  }

  /**
   * Unregister a plugin
   */
  unregisterPlugin(pluginId) {
    if (!this.registeredPlugins.has(pluginId)) {
      return { success: false, error: 'Plugin not found' };
    }

    // Remove any instances
    this.pluginInstances.delete(pluginId);
    
    // Remove hooks/filters
    this.removePluginHooks(pluginId);
    
    // Remove from registry
    this.registeredPlugins.delete(pluginId);

    return { success: true };
  }

  /**
   * Get plugin info
   */
  getPlugin(pluginId) {
    const plugin = this.registeredPlugins.get(pluginId);
    if (!plugin) return null;

    return {
      ...plugin.manifest,
      registeredAt: plugin.registeredAt,
      enabled: plugin.enabled,
      instances: plugin.instances,
    };
  }

  /**
   * List all plugins
   */
  listPlugins(filter = {}) {
    const plugins = Array.from(this.registeredPlugins.entries()).map(([id, data]) => ({
      id,
      ...data.manifest,
      registeredAt: data.registeredAt,
      enabled: data.enabled,
      instances: data.instances,
    }));

    if (filter.enabled !== undefined) {
      return plugins.filter(p => p.enabled === filter.enabled);
    }

    return plugins;
  }

  /**
   * Register hook handler
   */
  registerHook(pluginId, hookName, handler) {
    if (!this.hookRegistry.has(hookName)) {
      this.hookRegistry.set(hookName, []);
    }
    
    this.hookRegistry.get(hookName).push({
      pluginId,
      handler,
      priority: 10,
    });
  }

  /**
   * Register filter handler
   */
  registerFilter(pluginId, filterName, handler) {
    if (!this.filterRegistry.has(filterName)) {
      this.filterRegistry.set(filterName, []);
    }
    
    this.filterRegistry.get(filterName).push({
      pluginId,
      handler,
      priority: 10,
    });
  }

  /**
   * Execute hook
   */
  async executeHook(hookName, payload, context = {}) {
    const handlers = this.hookRegistry.get(hookName) || [];
    let result = payload;

    for (const { pluginId, handler } of handlers) {
      try {
        result = await handler(result, { ...context, pluginId });
      } catch (error) {
        console.error(`Hook error [${hookName}] from plugin [${pluginId}]:`, error);
      }
    }

    return result;
  }

  /**
   * Apply filter
   */
  async applyFilter(filterName, value, context = {}) {
    const handlers = this.filterRegistry.get(filterName) || [];
    let result = value;

    for (const { pluginId, handler } of handlers) {
      try {
        result = await handler(result, { ...context, pluginId });
      } catch (error) {
        console.error(`Filter error [${filterName}] from plugin [${pluginId}]:`, error);
      }
    }

    return result;
  }

  /**
   * Remove plugin hooks/filters
   */
  removePluginHooks(pluginId) {
    // Remove from hooks
    for (const [hookName, handlers] of this.hookRegistry.entries()) {
      this.hookRegistry.set(
        hookName,
        handlers.filter(h => h.pluginId !== pluginId),
      );
    }

    // Remove from filters
    for (const [filterName, handlers] of this.filterRegistry.entries()) {
      this.filterRegistry.set(
        filterName,
        handlers.filter(h => h.pluginId !== pluginId),
      );
    }
  }

  /**
   * Get available permissions
   */
  getAvailablePermissions() {
    return Object.entries(AVAILABLE_PERMISSIONS).map(([id, description]) => ({
      id,
      description,
      riskLevel: PERMISSION_RISK[id],
    }));
  }

  /**
   * Get SDK version and capabilities
   */
  getSDKInfo() {
    return {
      version: '1.0.0',
      availablePermissions: this.getAvailablePermissions(),
      availableHooks: [
        'plugin:init',
        'plugin:destroy',
        'tool:beforeExecute',
        'tool:afterExecute',
        'data:beforeSave',
        'data:afterSave',
        'chat:beforeSend',
        'chat:afterReceive',
      ],
      availableFilters: [
        'input:sanitize',
        'output:transform',
        'response:format',
        'error:handle',
      ],
      registeredPlugins: this.registeredPlugins.size,
      totalInstances: Array.from(this.pluginInstances.values()).reduce((sum, i) => sum + i, 0),
    };
  }
}

// Export singleton instance
const pluginSDK = new PluginSDK();
export default pluginSDK;
export { PluginSDK, AVAILABLE_PERMISSIONS, PERMISSION_RISK };

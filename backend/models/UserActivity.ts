/**
 * User Activity Model
 * Comprehensive user activity tracking and analytics
 */

import mongoose from 'mongoose'

const userActivitySchema = new mongoose.Schema({
  // Basic Information
  activityId: {
    type: String,
    unique: true,
    required: true,
    index: true
  },
  
  // User Reference
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  
  // Session Reference
  sessionId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'UserSession',\n    index: true\n  },\n  \n  // Activity Classification\n  type: {\n    type: String,\n    enum: [\n      // Navigation\n      'page_view', 'page_exit', 'navigation', 'redirect',\n      \n      // User Interactions\n      'click', 'double_click', 'right_click', 'hover', 'scroll', 'zoom', 'resize',\n      \n      // Form Interactions\n      'form_start', 'form_field_focus', 'form_field_blur', 'form_submit', 'form_abandon',\n      \n      // Content Interactions\n      'content_view', 'content_share', 'content_like', 'content_comment', 'content_save',\n      \n      // Media Interactions\n      'video_play', 'video_pause', 'video_complete', 'audio_play', 'image_view', 'file_download', 'file_upload',\n      \n      // Search and Discovery\n      'search', 'filter', 'sort', 'pagination', 'autocomplete_select',\n      \n      // E-commerce\n      'product_view', 'add_to_cart', 'remove_from_cart', 'checkout_start', 'purchase', 'wishlist_add',\n      \n      // Social\n      'follow', 'unfollow', 'message_send', 'notification_click', 'invite_send',\n      \n      // System Events\n      'login', 'logout', 'registration', 'password_change', 'profile_update',\n      \n      // API and Integration\n      'api_call', 'webhook_received', 'integration_sync', 'export', 'import',\n      \n      // Error Events\n      'error_encountered', 'bug_report', 'feedback_submit',\n      \n      // Custom Events\n      'custom'\n    ],\n    required: true,\n    index: true\n  },\n  \n  // Activity Category\n  category: {\n    type: String,\n    enum: ['engagement', 'conversion', 'navigation', 'interaction', 'system', 'error', 'social', 'content', 'commerce'],\n    required: true,\n    index: true\n  },\n  \n  // Activity Details\n  details: {\n    // Target Information\n    target: {\n      type: String, // element ID, URL, button name, etc.\n      index: true\n    },\n    \n    targetType: {\n      type: String,\n      enum: ['button', 'link', 'form', 'image', 'video', 'text', 'menu', 'modal', 'page', 'api_endpoint', 'other']\n    },\n    \n    // Action context\n    action: String, // specific action taken\n    value: mongoose.Schema.Types.Mixed, // action value (amount, text, etc.)\n    \n    // Page context\n    page: {\n      url: String,\n      path: String,\n      title: String,\n      referrer: String,\n      \n      // Page metadata\n      category: String,\n      tags: [String],\n      loadTime: Number\n    },\n    \n    // Element context (for UI interactions)\n    element: {\n      tagName: String,\n      className: String,\n      id: String,\n      text: String,\n      position: {\n        x: Number,\n        y: Number\n      },\n      \n      // Element attributes\n      attributes: mongoose.Schema.Types.Mixed\n    },\n    \n    // Form context (for form interactions)\n    form: {\n      formId: String,\n      fieldName: String,\n      fieldType: String,\n      fieldValue: String, // Should be sanitized for sensitive data\n      \n      // Form progress\n      completionPercentage: Number,\n      timeToComplete: Number,\n      errorsEncountered: Number\n    },\n    \n    // Content context\n    content: {\n      id: String,\n      type: String, // article, video, image, etc.\n      title: String,\n      author: String,\n      category: String,\n      tags: [String],\n      \n      // Engagement metrics\n      engagementScore: Number,\n      timeSpent: Number,\n      scrollDepth: Number\n    },\n    \n    // Search context\n    search: {\n      query: String,\n      filters: mongoose.Schema.Types.Mixed,\n      sortBy: String,\n      resultsCount: Number,\n      selectedResult: Number,\n      \n      // Search performance\n      responseTime: Number,\n      didYouMean: String\n    },\n    \n    // E-commerce context\n    commerce: {\n      productId: String,\n      productName: String,\n      category: String,\n      price: Number,\n      currency: String,\n      quantity: Number,\n      \n      // Transaction context\n      orderId: String,\n      paymentMethod: String,\n      discountCode: String,\n      totalAmount: Number\n    }\n  },\n  \n  // Technical Information\n  technical: {\n    // Browser and device\n    userAgent: String,\n    browser: String,\n    browserVersion: String,\n    os: String,\n    device: String,\n    \n    // Network\n    ipAddress: String,\n    location: {\n      country: String,\n      city: String,\n      timezone: String\n    },\n    \n    // Performance\n    performance: {\n      timestamp: Number, // performance.now()\n      loadTime: Number,\n      renderTime: Number,\n      networkLatency: Number\n    },\n    \n    // Viewport\n    viewport: {\n      width: Number,\n      height: Number,\n      scrollX: Number,\n      scrollY: Number,\n      zoom: Number\n    }\n  },\n  \n  // Timing Information\n  timing: {\n    // When the activity occurred\n    occurredAt: {\n      type: Date,\n      required: true,\n      default: Date.now,\n      index: true\n    },\n    \n    // Duration (for activities that have duration)\n    duration: Number, // milliseconds\n    \n    // Time since last activity\n    timeSinceLastActivity: Number, // milliseconds\n    \n    // Time on page when activity occurred\n    timeOnPage: Number, // milliseconds\n    \n    // Session time when activity occurred\n    sessionTime: Number, // milliseconds\n    \n    // Local time information\n    localTime: {\n      hour: Number,\n      dayOfWeek: Number,\n      month: Number,\n      year: Number,\n      timezone: String\n    }\n  },\n  \n  // Context and State\n  context: {\n    // User state at time of activity\n    userState: {\n      authenticated: Boolean,\n      subscriptionStatus: String,\n      accountAge: Number, // days\n      lifetimeValue: Number,\n      \n      // User preferences\n      language: String,\n      theme: String,\n      currency: String\n    },\n    \n    // Application state\n    appState: {\n      version: String,\n      feature: String, // current feature being used\n      mode: String, // light/dark, mobile/desktop\n      \n      // A/B test context\n      experiments: [{\n        name: String,\n        variant: String,\n        startedAt: Date\n      }],\n      \n      // Feature flags\n      featureFlags: [{\n        flag: String,\n        enabled: Boolean\n      }]\n    },\n    \n    // Campaign context\n    campaign: {\n      source: String,\n      medium: String,\n      campaign: String,\n      term: String,\n      content: String,\n      \n      // Attribution\n      firstTouch: Boolean,\n      lastTouch: Boolean\n    }\n  },\n  \n  // Analytics and Scoring\n  analytics: {\n    // Engagement scoring\n    engagementScore: {\n      type: Number,\n      min: 0,\n      max: 100,\n      default: 0\n    },\n    \n    // Value scoring\n    valueScore: {\n      type: Number,\n      min: 0,\n      max: 100,\n      default: 0\n    },\n    \n    // Intent prediction\n    intent: {\n      predicted: String, // purchase, browse, research, etc.\n      confidence: { type: Number, min: 0, max: 1 },\n      model: String,\n      version: String\n    },\n    \n    // Conversion attribution\n    conversion: {\n      isConversion: Boolean,\n      conversionType: String,\n      conversionValue: Number,\n      \n      // Attribution\n      touchpointPosition: String, // first, middle, last\n      influenceScore: Number\n    },\n    \n    // Cohort information\n    cohort: {\n      userCohort: String, // based on registration date\n      behaviorCohort: String, // based on behavior patterns\n      valueCohort: String // based on value/spending\n    }\n  },\n  \n  // Quality and Validation\n  quality: {\n    // Data quality indicators\n    confidence: {\n      type: Number,\n      min: 0,\n      max: 1,\n      default: 1\n    },\n    \n    // Validation status\n    validated: {\n      type: Boolean,\n      default: false\n    },\n    \n    // Data source reliability\n    sourceReliability: {\n      type: String,\n      enum: ['high', 'medium', 'low'],\n      default: 'medium'\n    },\n    \n    // Potential issues\n    issues: [{\n      type: String,\n      severity: String,\n      description: String,\n      detected: { type: Date, default: Date.now }\n    }],\n    \n    // Bot detection\n    botScore: {\n      type: Number,\n      min: 0,\n      max: 1,\n      default: 0\n    }\n  },\n  \n  // Privacy and Compliance\n  privacy: {\n    // PII handling\n    containsPII: {\n      type: Boolean,\n      default: false\n    },\n    \n    // Data processing consent\n    processingConsent: {\n      type: Boolean,\n      default: true\n    },\n    \n    // Anonymization status\n    anonymized: {\n      type: Boolean,\n      default: false\n    },\n    \n    // Retention policy\n    retentionPolicy: {\n      category: String,\n      retainUntil: Date,\n      anonymizeAfter: Date\n    },\n    \n    // Geographic restrictions\n    geographicRestrictions: [String]\n  },\n  \n  // Related Activities\n  relationships: {\n    // Parent activity (for hierarchical activities)\n    parentActivity: {\n      type: mongoose.Schema.Types.ObjectId,\n      ref: 'UserActivity'\n    },\n    \n    // Related activities\n    relatedActivities: [{\n      activityId: mongoose.Schema.Types.ObjectId,\n      relationship: String // caused_by, followed_by, part_of\n    }],\n    \n    // Funnel position\n    funnel: {\n      name: String,\n      step: Number,\n      completed: Boolean,\n      abandoned: Boolean\n    }\n  },\n  \n  // Custom Data\n  customData: {\n    // Custom fields for specific implementations\n    fields: mongoose.Schema.Types.Mixed,\n    \n    // Tags for categorization\n    tags: [String],\n    \n    // External references\n    externalReferences: [{\n      system: String,\n      id: String,\n      type: String\n    }]\n  }\n}, {\n  timestamps: true,\n  toJSON: { virtuals: true },\n  toObject: { virtuals: true }\n})\n\n// Indexes for performance\nuserActivitySchema.index({ userId: 1, 'timing.occurredAt': -1 })\nuserActivitySchema.index({ type: 1, category: 1 })\nuserActivitySchema.index({ sessionId: 1, 'timing.occurredAt': 1 })\nuserActivitySchema.index({ 'timing.occurredAt': -1 })\nuserActivitySchema.index({ 'details.target': 1 })\nuserActivitySchema.index({ activityId: 1 }, { unique: true })\n\n// Compound indexes for common queries\nuserActivitySchema.index({ userId: 1, type: 1, 'timing.occurredAt': -1 })\nuserActivitySchema.index({ category: 1, 'timing.occurredAt': -1 })\nuserActivitySchema.index({ 'analytics.conversion.isConversion': 1, userId: 1 })\n\n// TTL index for data retention\nuserActivitySchema.index(\n  { 'timing.occurredAt': 1 },\n  { \n    expireAfterSeconds: 60 * 60 * 24 * 365 * 2, // 2 years\n    partialFilterExpression: { 'privacy.retentionPolicy.retainUntil': { $exists: false } }\n  }\n)\n\n// Virtual for activity age\nuserActivitySchema.virtual('age').get(function() {\n  return new Date() - this.timing.occurredAt\n})\n\n// Virtual for is recent\nuserActivitySchema.virtual('isRecent').get(function() {\n  const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000)\n  return this.timing.occurredAt > oneHourAgo\n})\n\n// Virtual for is conversion\nuserActivitySchema.virtual('isConversion').get(function() {\n  return this.analytics?.conversion?.isConversion || false\n})\n\n// Static methods\nuserActivitySchema.statics.findByUser = function(userId, options = {}) {\n  const { limit = 100, type, category, startDate, endDate } = options\n  \n  const query = { userId }\n  \n  if (type) query.type = type\n  if (category) query.category = category\n  \n  if (startDate || endDate) {\n    query['timing.occurredAt'] = {}\n    if (startDate) query['timing.occurredAt'].$gte = startDate\n    if (endDate) query['timing.occurredAt'].$lte = endDate\n  }\n  \n  return this.find(query)\n    .sort({ 'timing.occurredAt': -1 })\n    .limit(limit)\n}\n\nuserActivitySchema.statics.findBySession = function(sessionId) {\n  return this.find({ sessionId })\n    .sort({ 'timing.occurredAt': 1 })\n}\n\nuserActivitySchema.statics.getActivitySummary = function(userId, timeframe = 24) {\n  const startDate = new Date(Date.now() - timeframe * 60 * 60 * 1000)\n  \n  return this.aggregate([\n    {\n      $match: {\n        userId: mongoose.Types.ObjectId(userId),\n        'timing.occurredAt': { $gte: startDate }\n      }\n    },\n    {\n      $group: {\n        _id: {\n          type: '$type',\n          category: '$category'\n        },\n        count: { $sum: 1 },\n        avgEngagement: { $avg: '$analytics.engagementScore' },\n        totalValue: { $sum: '$analytics.valueScore' },\n        conversions: {\n          $sum: {\n            $cond: ['$analytics.conversion.isConversion', 1, 0]\n          }\n        }\n      }\n    },\n    { $sort: { count: -1 } }\n  ])\n}\n\nuserActivitySchema.statics.getFunnelAnalysis = function(funnelName, timeframe = 7) {\n  const startDate = new Date(Date.now() - timeframe * 24 * 60 * 60 * 1000)\n  \n  return this.aggregate([\n    {\n      $match: {\n        'relationships.funnel.name': funnelName,\n        'timing.occurredAt': { $gte: startDate }\n      }\n    },\n    {\n      $group: {\n        _id: {\n          step: '$relationships.funnel.step',\n          userId: '$userId'\n        },\n        completed: { $max: '$relationships.funnel.completed' },\n        abandoned: { $max: '$relationships.funnel.abandoned' }\n      }\n    },\n    {\n      $group: {\n        _id: '$_id.step',\n        totalUsers: { $sum: 1 },\n        completedUsers: {\n          $sum: { $cond: ['$completed', 1, 0] }\n        },\n        abandonedUsers: {\n          $sum: { $cond: ['$abandoned', 1, 0] }\n        }\n      }\n    },\n    { $sort: { '_id': 1 } }\n  ])\n}\n\nuserActivitySchema.statics.getEngagementTrends = function(timeframe = 30) {\n  const startDate = new Date(Date.now() - timeframe * 24 * 60 * 60 * 1000)\n  \n  return this.aggregate([\n    {\n      $match: {\n        'timing.occurredAt': { $gte: startDate },\n        category: 'engagement'\n      }\n    },\n    {\n      $group: {\n        _id: {\n          $dateToString: {\n            format: '%Y-%m-%d',\n            date: '$timing.occurredAt'\n          }\n        },\n        totalActivities: { $sum: 1 },\n        uniqueUsers: { $addToSet: '$userId' },\n        avgEngagement: { $avg: '$analytics.engagementScore' }\n      }\n    },\n    {\n      $project: {\n        date: '$_id',\n        totalActivities: 1,\n        uniqueUsers: { $size: '$uniqueUsers' },\n        avgEngagement: 1\n      }\n    },\n    { $sort: { date: 1 } }\n  ])\n}\n\n// Instance methods\nuserActivitySchema.methods.calculateEngagementScore = function() {\n  let score = 0\n  \n  // Base score by activity type\n  const typeScores = {\n    'page_view': 5,\n    'click': 10,\n    'form_submit': 25,\n    'purchase': 100,\n    'share': 30,\n    'comment': 40,\n    'search': 15\n  }\n  \n  score += typeScores[this.type] || 5\n  \n  // Time-based scoring\n  if (this.timing.duration) {\n    const minutes = this.timing.duration / (1000 * 60)\n    if (minutes > 1) score += Math.min(minutes * 2, 20) // Cap at 20 points\n  }\n  \n  // Context-based scoring\n  if (this.context?.userState?.authenticated) score += 5\n  if (this.details?.content?.scrollDepth > 50) score += 10\n  \n  this.analytics.engagementScore = Math.min(100, score)\n  return this.analytics.engagementScore\n}\n\nuserActivitySchema.methods.calculateValueScore = function() {\n  let score = 0\n  \n  // Direct value activities\n  if (this.type === 'purchase' && this.details?.commerce?.totalAmount) {\n    score = Math.min(100, this.details.commerce.totalAmount / 10) // $10 = 100 points\n  }\n  \n  // Lead generation activities\n  if (this.type === 'form_submit') {\n    score = 30\n  }\n  \n  // Engagement value\n  if (this.type === 'content_share') score = 15\n  if (this.type === 'follow') score = 10\n  \n  this.analytics.valueScore = score\n  return score\n}\n\nuserActivitySchema.methods.predictIntent = function() {\n  // Simple intent prediction based on activity patterns\n  const recentActivities = [] // This would be populated from recent user activities\n  \n  let intent = 'browse'\n  let confidence = 0.5\n  \n  // Purchase intent indicators\n  if (this.type === 'product_view' || this.type === 'add_to_cart') {\n    intent = 'purchase'\n    confidence = 0.7\n  }\n  \n  if (this.type === 'checkout_start') {\n    intent = 'purchase'\n    confidence = 0.9\n  }\n  \n  // Research intent\n  if (this.type === 'search' || this.type === 'content_view') {\n    intent = 'research'\n    confidence = 0.6\n  }\n  \n  this.analytics.intent = {\n    predicted: intent,\n    confidence,\n    model: 'simple_rules',\n    version: '1.0'\n  }\n  \n  return this.analytics.intent\n}\n\nuserActivitySchema.methods.markAsConversion = function(conversionType, value = 0) {\n  this.analytics.conversion = {\n    isConversion: true,\n    conversionType,\n    conversionValue: value,\n    touchpointPosition: 'last', // This would be calculated based on user journey\n    influenceScore: 1.0\n  }\n  \n  return this.save()\n}\n\nuserActivitySchema.methods.addRelatedActivity = function(activityId, relationship) {\n  this.relationships.relatedActivities.push({\n    activityId,\n    relationship\n  })\n  \n  return this.save()\n}\n\nuserActivitySchema.methods.anonymize = function() {\n  // Remove or hash PII\n  if (this.technical.ipAddress) {\n    this.technical.ipAddress = this.technical.ipAddress.substring(0, \n      this.technical.ipAddress.lastIndexOf('.')) + '.0'\n  }\n  \n  // Remove detailed location\n  if (this.technical.location) {\n    delete this.technical.location.city\n    // Keep country and timezone for analytics\n  }\n  \n  // Remove user agent details\n  if (this.technical.userAgent) {\n    this.technical.userAgent = 'anonymized'\n  }\n  \n  // Mark as anonymized\n  this.privacy.anonymized = true\n  this.privacy.containsPII = false\n  \n  return this.save()\n}\n\n// Pre-save middleware\nuserActivitySchema.pre('save', function(next) {\n  // Generate activity ID if new\n  if (this.isNew && !this.activityId) {\n    this.activityId = `act_${Date.now()}_${Math.random().toString(36).substr(2, 12)}`\n  }\n  \n  // Calculate scores if not set\n  if (this.isNew || this.isModified(['type', 'details', 'timing'])) {\n    this.calculateEngagementScore()\n    this.calculateValueScore()\n    this.predictIntent()\n  }\n  \n  // Set local time information\n  if (this.isNew && this.timing.occurredAt) {\n    const date = new Date(this.timing.occurredAt)\n    this.timing.localTime = {\n      hour: date.getHours(),\n      dayOfWeek: date.getDay(),\n      month: date.getMonth() + 1,\n      year: date.getFullYear(),\n      timezone: this.technical?.location?.timezone || 'UTC'\n    }\n  }\n  \n  // Auto-detect PII\n  if (this.details?.form?.fieldValue) {\n    const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}/\n    const phoneRegex = /\\d{3}-\\d{3}-\\d{4}|\\(\\d{3}\\)\\s*\\d{3}-\\d{4}/\n    \n    if (emailRegex.test(this.details.form.fieldValue) || \n        phoneRegex.test(this.details.form.fieldValue)) {\n      this.privacy.containsPII = true\n    }\n  }\n  \n  next()\n})\n\nexport default mongoose.model('UserActivity', userActivitySchema)"
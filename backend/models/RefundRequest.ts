/**
 * Refund Request Model
 * Comprehensive refund processing and management
 */

import mongoose from 'mongoose'

const refundRequestSchema = new mongoose.Schema({
  // Basic Information
  refundId: {
    type: String,
    unique: true,
    required: true,
    index: true
  },
  
  // References
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  
  transactionId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Transaction',
    required: true,
    index: true
  },
  
  invoiceId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Invoice',
    index: true
  },
  
  subscriptionId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Subscription',
    index: true
  },
  
  // External Provider References
  externalIds: {
    stripeRefundId: String,
    paypalRefundId: String,
    providerRefundId: String,
    
    // Original payment references
    stripePaymentIntentId: String,
    stripeChargeId: String
  },
  
  // Refund Details
  refundType: {
    type: String,
    enum: ['full', 'partial', 'chargeback', 'dispute'],
    required: true
  },
  
  category: {
    type: String,
    enum: ['customer_request', 'service_issue', 'billing_error', 'fraud', 'duplicate_payment', 'cancelled_service', 'technical_issue', 'policy_violation', 'other'],\n    required: true\n  },\n  \n  // Financial Information\n  amounts: {\n    // Original transaction amount\n    originalAmount: {\n      type: Number,\n      required: true,\n      min: 0\n    },\n    \n    // Requested refund amount\n    requestedAmount: {\n      type: Number,\n      required: true,\n      min: 0\n    },\n    \n    // Approved refund amount (may differ from requested)\n    approvedAmount: {\n      type: Number,\n      min: 0\n    },\n    \n    // Actual processed amount\n    processedAmount: {\n      type: Number,\n      min: 0\n    },\n    \n    // Fees and deductions\n    processingFee: {\n      type: Number,\n      default: 0,\n      min: 0\n    },\n    \n    chargebackFee: {\n      type: Number,\n      default: 0,\n      min: 0\n    },\n    \n    // Net amount to customer\n    netRefundAmount: {\n      type: Number,\n      min: 0\n    },\n    \n    currency: {\n      type: String,\n      required: true,\n      default: 'USD',\n      maxlength: 3\n    }\n  },\n  \n  // Request Information\n  request: {\n    // Reason for refund\n    reason: {\n      type: String,\n      required: true,\n      maxlength: 1000\n    },\n    \n    // Detailed explanation\n    description: {\n      type: String,\n      maxlength: 5000\n    },\n    \n    // Request method\n    requestMethod: {\n      type: String,\n      enum: ['customer_portal', 'support_ticket', 'email', 'phone', 'admin_initiated', 'automatic'],\n      default: 'customer_portal'\n    },\n    \n    // Supporting documentation\n    attachments: [{\n      filename: String,\n      originalName: String,\n      url: String,\n      type: String,\n      size: Number,\n      uploadedAt: { type: Date, default: Date.now }\n    }],\n    \n    // Customer contact information at time of request\n    contactInfo: {\n      email: String,\n      phone: String,\n      preferredContactMethod: String\n    },\n    \n    // Request metadata\n    metadata: {\n      userAgent: String,\n      ipAddress: String,\n      referrer: String,\n      sessionId: String\n    }\n  },\n  \n  // Status and Processing\n  status: {\n    type: String,\n    enum: ['pending', 'under_review', 'approved', 'partially_approved', 'rejected', 'processing', 'completed', 'failed', 'cancelled', 'disputed'],\n    default: 'pending',\n    index: true\n  },\n  \n  // Priority and Urgency\n  priority: {\n    type: String,\n    enum: ['low', 'normal', 'high', 'urgent', 'critical'],\n    default: 'normal',\n    index: true\n  },\n  \n  // Processing Information\n  processing: {\n    // Assigned processor\n    assignedTo: {\n      userId: mongoose.Schema.Types.ObjectId,\n      name: String,\n      role: String,\n      assignedAt: Date\n    },\n    \n    // Processing method\n    method: {\n      type: String,\n      enum: ['automatic', 'manual_review', 'escalated'],\n      default: 'automatic'\n    },\n    \n    // Review information\n    review: {\n      reviewer: {\n        userId: mongoose.Schema.Types.ObjectId,\n        name: String,\n        role: String\n      },\n      \n      reviewedAt: Date,\n      \n      decision: {\n        type: String,\n        enum: ['approve_full', 'approve_partial', 'reject', 'escalate', 'request_more_info']\n      },\n      \n      reasoning: String,\n      \n      notes: String,\n      \n      // Risk assessment\n      riskScore: {\n        type: Number,\n        min: 0,\n        max: 100\n      },\n      \n      flags: [{\n        type: String,\n        severity: String,\n        description: String\n      }]\n    },\n    \n    // Approval workflow\n    approvals: [{\n      approver: {\n        userId: mongoose.Schema.Types.ObjectId,\n        name: String,\n        role: String\n      },\n      \n      action: {\n        type: String,\n        enum: ['approved', 'rejected', 'escalated', 'requested_changes']\n      },\n      \n      comments: String,\n      timestamp: { type: Date, default: Date.now },\n      \n      // Approval limits\n      authorizedAmount: Number\n    }],\n    \n    // Processing timeline\n    timeline: {\n      submittedAt: Date,\n      reviewStartedAt: Date,\n      approvedAt: Date,\n      processingStartedAt: Date,\n      completedAt: Date,\n      \n      // SLA tracking\n      expectedCompletionAt: Date,\n      actualProcessingTime: Number, // minutes\n      \n      // Delays\n      delays: [{\n        reason: String,\n        duration: Number, // minutes\n        startedAt: Date,\n        resolvedAt: Date\n      }]\n    }\n  },\n  \n  // Payment Provider Processing\n  providerProcessing: {\n    provider: {\n      type: String,\n      enum: ['stripe', 'paypal', 'square', 'braintree']\n    },\n    \n    // Provider response\n    providerResponse: {\n      status: String,\n      message: String,\n      code: String,\n      timestamp: Date,\n      rawResponse: mongoose.Schema.Types.Mixed\n    },\n    \n    // Refund attempts\n    attempts: [{\n      attemptNumber: Number,\n      status: String,\n      amount: Number,\n      fee: Number,\n      \n      response: {\n        success: Boolean,\n        message: String,\n        code: String,\n        transactionId: String\n      },\n      \n      timestamp: { type: Date, default: Date.now },\n      \n      // Error details\n      error: {\n        type: String,\n        message: String,\n        retryable: Boolean\n      }\n    }],\n    \n    // Expected settlement\n    settlement: {\n      expectedDate: Date,\n      actualDate: Date,\n      bankAccount: String, // Last 4 digits\n      reference: String\n    }\n  },\n  \n  // Customer Communication\n  communications: [{\n    type: {\n      type: String,\n      enum: ['email', 'sms', 'phone', 'in_app', 'letter']\n    },\n    \n    direction: {\n      type: String,\n      enum: ['inbound', 'outbound']\n    },\n    \n    subject: String,\n    message: String,\n    \n    // Communication metadata\n    sender: {\n      type: String, // email or phone\n      name: String,\n      role: String\n    },\n    \n    recipient: {\n      type: String,\n      name: String\n    },\n    \n    status: {\n      type: String,\n      enum: ['sent', 'delivered', 'read', 'replied', 'failed']\n    },\n    \n    timestamp: { type: Date, default: Date.now },\n    \n    // Attachments\n    attachments: [{\n      filename: String,\n      url: String,\n      size: Number\n    }]\n  }],\n  \n  // Dispute Information (for chargebacks)\n  dispute: {\n    isDispute: { type: Boolean, default: false },\n    \n    disputeId: String,\n    disputeReason: String,\n    \n    // Dispute timeline\n    disputedAt: Date,\n    respondByDate: Date,\n    resolvedAt: Date,\n    \n    // Bank/Card issuer info\n    issuer: {\n      bank: String,\n      country: String,\n      reasonCode: String\n    },\n    \n    // Our response\n    response: {\n      submitted: Boolean,\n      submittedAt: Date,\n      evidence: [{\n        type: String,\n        description: String,\n        url: String\n      }],\n      \n      outcome: {\n        type: String,\n        enum: ['won', 'lost', 'accepted', 'pending']\n      },\n      \n      outcomeAt: Date\n    }\n  },\n  \n  // Business Rules and Policies\n  policies: {\n    // Eligibility\n    eligibilityChecks: [{\n      check: String,\n      passed: Boolean,\n      reason: String,\n      timestamp: Date\n    }],\n    \n    // Applied policies\n    appliedPolicies: [{\n      policyId: String,\n      policyName: String,\n      version: String,\n      effect: String, // allow, deny, modify\n      details: mongoose.Schema.Types.Mixed\n    }],\n    \n    // Policy overrides\n    overrides: [{\n      policy: String,\n      originalDecision: String,\n      newDecision: String,\n      reason: String,\n      \n      authorizedBy: {\n        userId: mongoose.Schema.Types.ObjectId,\n        name: String,\n        role: String\n      },\n      \n      timestamp: { type: Date, default: Date.now }\n    }]\n  },\n  \n  // Analytics and Reporting\n  analytics: {\n    // Classification\n    fraudRisk: {\n      score: { type: Number, min: 0, max: 100 },\n      factors: [String],\n      model: String,\n      version: String\n    },\n    \n    // Customer profile\n    customerProfile: {\n      totalRefunds: Number,\n      refundFrequency: Number,\n      averageRefundAmount: Number,\n      riskCategory: String\n    },\n    \n    // Processing metrics\n    metrics: {\n      processingTime: Number, // minutes\n      touchpoints: Number,\n      escalations: Number,\n      customerSatisfaction: Number\n    },\n    \n    // Tags for reporting\n    tags: [String],\n    \n    // Custom analytics data\n    customData: mongoose.Schema.Types.Mixed\n  },\n  \n  // Integration and Webhooks\n  integration: {\n    // External system notifications\n    webhooks: [{\n      url: String,\n      event: String,\n      status: String,\n      attempts: Number,\n      lastAttempt: Date,\n      response: String\n    }],\n    \n    // Third-party integrations\n    integrations: [{\n      system: String,\n      reference: String,\n      status: String,\n      data: mongoose.Schema.Types.Mixed\n    }]\n  },\n  \n  // Notes and Internal Comments\n  internalNotes: [{\n    author: {\n      userId: mongoose.Schema.Types.ObjectId,\n      name: String,\n      role: String\n    },\n    \n    note: String,\n    \n    type: {\n      type: String,\n      enum: ['general', 'review', 'decision', 'escalation', 'customer_service']\n    },\n    \n    visibility: {\n      type: String,\n      enum: ['internal', 'management', 'customer_service'],\n      default: 'internal'\n    },\n    \n    timestamp: { type: Date, default: Date.now }\n  }],\n  \n  // Audit Trail\n  auditTrail: [{\n    action: {\n      type: String,\n      enum: ['created', 'updated', 'reviewed', 'approved', 'rejected', 'processed', 'completed', 'cancelled']\n    },\n    \n    details: mongoose.Schema.Types.Mixed,\n    \n    actor: {\n      type: { type: String, enum: ['user', 'system', 'admin', 'api'] },\n      id: mongoose.Schema.Types.ObjectId,\n      name: String,\n      ipAddress: String,\n      userAgent: String\n    },\n    \n    timestamp: { type: Date, default: Date.now }\n  }]\n}, {\n  timestamps: true,\n  toJSON: { virtuals: true },\n  toObject: { virtuals: true }\n})\n\n// Indexes for performance\nrefundRequestSchema.index({ userId: 1, status: 1 })\nrefundRequestSchema.index({ transactionId: 1 })\nrefundRequestSchema.index({ status: 1, priority: 1 })\nrefundRequestSchema.index({ 'processing.assignedTo.userId': 1 })\nrefundRequestSchema.index({ createdAt: -1 })\nrefundRequestSchema.index({ refundId: 1 }, { unique: true })\nrefundRequestSchema.index({ 'externalIds.stripeRefundId': 1 })\nrefundRequestSchema.index({ category: 1, status: 1 })\n\n// Virtual for refund percentage\nrefundRequestSchema.virtual('refundPercentage').get(function() {\n  if (!this.amounts.originalAmount || this.amounts.originalAmount === 0) return 0\n  const amount = this.amounts.processedAmount || this.amounts.approvedAmount || this.amounts.requestedAmount\n  return Math.round((amount / this.amounts.originalAmount) * 100)\n})\n\n// Virtual for processing time\nrefundRequestSchema.virtual('processingDuration').get(function() {\n  const start = this.processing.timeline.submittedAt\n  const end = this.processing.timeline.completedAt || new Date()\n  \n  if (!start) return 0\n  return Math.round((end - start) / (1000 * 60)) // minutes\n})\n\n// Virtual for is overdue\nrefundRequestSchema.virtual('isOverdue').get(function() {\n  if (!this.processing.timeline.expectedCompletionAt) return false\n  if (this.status === 'completed' || this.status === 'cancelled') return false\n  \n  return new Date() > this.processing.timeline.expectedCompletionAt\n})\n\n// Static methods\nrefundRequestSchema.statics.findPending = function() {\n  return this.find({\n    status: { $in: ['pending', 'under_review', 'approved'] }\n  }).sort({ priority: -1, createdAt: 1 })\n}\n\nrefundRequestSchema.statics.findByUser = function(userId, options = {}) {\n  return this.find({ userId }, null, options)\n    .populate('transactionId')\n    .populate('invoiceId')\n    .sort({ createdAt: -1 })\n}\n\nrefundRequestSchema.statics.getStatsByPeriod = function(days = 30) {\n  const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000)\n  \n  return this.aggregate([\n    { $match: { createdAt: { $gte: startDate } } },\n    {\n      $group: {\n        _id: {\n          status: '$status',\n          category: '$category'\n        },\n        count: { $sum: 1 },\n        totalAmount: { $sum: '$amounts.requestedAmount' },\n        averageAmount: { $avg: '$amounts.requestedAmount' },\n        averageProcessingTime: { $avg: '$processing.timeline.actualProcessingTime' }\n      }\n    },\n    { $sort: { '_id.status': 1, count: -1 } }\n  ])\n}\n\nrefundRequestSchema.statics.findOverdue = function() {\n  return this.find({\n    status: { $in: ['pending', 'under_review', 'approved', 'processing'] },\n    'processing.timeline.expectedCompletionAt': { $lt: new Date() }\n  }).sort({ 'processing.timeline.expectedCompletionAt': 1 })\n}\n\n// Instance methods\nrefundRequestSchema.methods.approve = function(approvedAmount, approverId, comments) {\n  this.status = 'approved'\n  this.amounts.approvedAmount = approvedAmount || this.amounts.requestedAmount\n  \n  this.processing.approvals.push({\n    approver: {\n      userId: approverId,\n      role: 'approver'\n    },\n    action: 'approved',\n    comments,\n    authorizedAmount: this.amounts.approvedAmount\n  })\n  \n  this.processing.timeline.approvedAt = new Date()\n  this.addAuditEntry('approved', { amount: this.amounts.approvedAmount, comments })\n  \n  return this.save()\n}\n\nrefundRequestSchema.methods.reject = function(reason, rejectedBy) {\n  this.status = 'rejected'\n  \n  this.processing.approvals.push({\n    approver: {\n      userId: rejectedBy,\n      role: 'reviewer'\n    },\n    action: 'rejected',\n    comments: reason\n  })\n  \n  this.addAuditEntry('rejected', { reason })\n  \n  return this.save()\n}\n\nrefundRequestSchema.methods.startProcessing = function() {\n  this.status = 'processing'\n  this.processing.timeline.processingStartedAt = new Date()\n  \n  this.addAuditEntry('processing_started')\n  \n  return this.save()\n}\n\nrefundRequestSchema.methods.complete = function(processedAmount, providerResponse) {\n  this.status = 'completed'\n  this.amounts.processedAmount = processedAmount\n  this.amounts.netRefundAmount = processedAmount - (this.amounts.processingFee || 0)\n  \n  this.processing.timeline.completedAt = new Date()\n  this.processing.timeline.actualProcessingTime = this.processingDuration\n  \n  if (providerResponse) {\n    this.providerProcessing.providerResponse = providerResponse\n  }\n  \n  this.addAuditEntry('completed', { \n    processedAmount,\n    netAmount: this.amounts.netRefundAmount\n  })\n  \n  return this.save()\n}\n\nrefundRequestSchema.methods.addProcessingAttempt = function(amount, response, error = null) {\n  const attemptNumber = this.providerProcessing.attempts.length + 1\n  \n  this.providerProcessing.attempts.push({\n    attemptNumber,\n    status: response.success ? 'success' : 'failed',\n    amount,\n    response,\n    error\n  })\n  \n  if (response.success) {\n    this.complete(amount, response)\n  } else if (error && !error.retryable) {\n    this.status = 'failed'\n  }\n  \n  return this.save()\n}\n\nrefundRequestSchema.methods.assignProcessor = function(userId, name, role) {\n  this.processing.assignedTo = {\n    userId,\n    name,\n    role,\n    assignedAt: new Date()\n  }\n  \n  this.addAuditEntry('assigned', { assignedTo: name, role })\n  \n  return this.save()\n}\n\nrefundRequestSchema.methods.addCommunication = function(type, direction, content, sender) {\n  this.communications.push({\n    type,\n    direction,\n    subject: content.subject,\n    message: content.message,\n    sender,\n    status: 'sent'\n  })\n  \n  return this.save()\n}\n\nrefundRequestSchema.methods.addInternalNote = function(authorId, authorName, note, type = 'general') {\n  this.internalNotes.push({\n    author: {\n      userId: authorId,\n      name: authorName\n    },\n    note,\n    type\n  })\n  \n  return this.save()\n}\n\nrefundRequestSchema.methods.escalate = function(reason, escalatedBy) {\n  this.priority = 'high'\n  this.processing.method = 'escalated'\n  \n  this.addInternalNote(escalatedBy, 'System', `Escalated: ${reason}`, 'escalation')\n  this.addAuditEntry('escalated', { reason })\n  \n  return this.save()\n}\n\nrefundRequestSchema.methods.addAuditEntry = function(action, details = {}, actor = {}) {\n  this.auditTrail.push({\n    action,\n    details,\n    actor: {\n      type: actor.type || 'system',\n      id: actor.id,\n      name: actor.name,\n      ipAddress: actor.ipAddress,\n      userAgent: actor.userAgent\n    }\n  })\n}\n\n// Pre-save middleware\nrefundRequestSchema.pre('save', function(next) {\n  // Generate refund ID if new\n  if (this.isNew && !this.refundId) {\n    this.refundId = `REF-${Date.now()}-${Math.random().toString(36).substr(2, 9).toUpperCase()}`\n  }\n  \n  // Set expected completion date based on priority and type\n  if (this.isNew || this.isModified('priority')) {\n    const hours = {\n      'low': 72,\n      'normal': 48,\n      'high': 24,\n      'urgent': 12,\n      'critical': 4\n    }\n    \n    this.processing.timeline.expectedCompletionAt = new Date(\n      Date.now() + (hours[this.priority] || 48) * 60 * 60 * 1000\n    )\n  }\n  \n  // Calculate net refund amount\n  if (this.isModified(['amounts.processedAmount', 'amounts.processingFee', 'amounts.chargebackFee'])) {\n    const processed = this.amounts.processedAmount || 0\n    const fees = (this.amounts.processingFee || 0) + (this.amounts.chargebackFee || 0)\n    this.amounts.netRefundAmount = Math.max(0, processed - fees)\n  }\n  \n  next()\n})\n\nexport default mongoose.model('RefundRequest', refundRequestSchema)"